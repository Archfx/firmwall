#!/usr/bin/env python

import sys
import claripy
import angr
from angrutils import *
import networkx as nx
import argparse

import re

import csv
import yaml

import logging
logging.getLogger('angr.analyses').setLevel('ERROR')
logging.getLogger('angr').setLevel('ERROR')

path = ""
elf_file = ""
func_file = ""

def load_spec(yaml_file):
    with open(yaml_file, 'r') as file:
        return yaml.safe_load(file)

def decode_fn_spec(spec_fn, imp_fn):
    if imp_fn in spec_fn:
        function_details = spec_fn[imp_fn]
        inputs = function_details["inputs"]
        return inputs
    else:
        raise ValueError(f"Function '{function_name}' not found in PSA Crypto functions")


def write_functions_csv( functions, save_csv=True):
	functions = []
	# Iterate over functions and collect data
	for func_addr, func in cfg.kb.functions.items():
		functions.append({
			"func_name": func.name,
			"func_addr": hex(func_addr)
		})
	if (save_csv):
		fields = ["func_name", "func_addr"]
		with open(func_file, mode='w', newline='') as file:
			writer = csv.DictWriter(file, fieldnames=fields)
			writer.writeheader()
			for func in functions:
				writer.writerow(func)
	return functions

def save_cfg(project, start_fn, cfg_name):
	main = project.loader.main_object.get_symbol(start_fn)
	start_state = project.factory.blank_state(addr=main.rebased_addr)
	cfg = project.analyses.CFGEmulated(fail_fast=True, starts=[main.rebased_addr], initial_state=start_state)
	plot_cfg(cfg, cfg_name, format="svg", asminst=True, remove_imports=True, remove_path_terminator=True)

# Function to locate the address of psa_sign_hash
def locate_function(project, func_name):
    cfg = project.analyses.CFGFast()
    for func_addr, func in cfg.kb.functions.items():
        if func.name == func_name:
            return func_addr
    return None

def get_subgraphs_to_end_nodes(cfg_graph, end_nodes):
    # Reverse the graph
    reversed_cfg = cfg_graph.reverse()

    subgraphs = {}
    for end_node in end_nodes:
        # Use DFS to find all reachable nodes from the end node in the reversed graph
        reachable_nodes = set(nx.dfs_preorder_nodes(reversed_cfg, source=end_node))
        
        # Extract the subgraph from the original CFG
        subgraph = cfg_graph.subgraph(reachable_nodes).copy()
        
        subgraphs[end_node] = subgraph

    return subgraphs

# Function to extract address from the CFGNode string
def extract_address(node_str):
    # Example: "ecdsa_verify_psa+0x74"
    match = re.search(r'\+(0x[0-9a-fA-F]+)', node_str)
    if match:
        return int(match.group(1), 16)
    else:
        raise ValueError("Invalid node string format")

def get_starting_nodes(subgraph):
	starting_nodes = []
	starting_addrs = []
	for node in subgraph.nodes:
		if subgraph.in_degree(node) == 0:  # No predecessors
			starting_nodes.append(node.name)
			starting_addrs.append(node.addr)
	return starting_nodes, starting_addrs

# Define a path constraint to reach the function
def is_at_function(state):
	return state.addr == function_address


def get_args():
	# Create the parser
	parser = argparse.ArgumentParser(description="Firmware firmware binary analysis tool.")

	# Add arguments
	parser.add_argument('-d', '--dumpfn', action='store_true', help='Dump available functions in the firmware')
	# parser.add_argument('-n', '--number', type=int, help='A number to process')
	# parser.add_argument('-s', '--string', type=str, help='A string to process')
	# parser.add_argument('-l', '--list', nargs='+', help='A list of values')

	# Parse the arguments
	args = parser.parse_args()

	# Use the arguments
	# if args.verbose:
	#     print("Verbose mode enabled")

	return args.dumpfn

def getFuncAddress( funcName, plt=None ):
        found = [
            addr for addr,func in cfg.kb.functions.items()
            if funcName == func.name and (plt is None or func.is_plt == plt)
            ]
        if len( found ) > 0:
            print("Found "+funcName+"'s address at "+hex(found[0])+"!")
            return found[0]
        else:
            raise Exception("No address found for function : "+funcName)

class serviceInfo:
	def __init__(self, starting_nodes, starting_addrs, end_node, subgraph):
		self.starting_nodes = starting_nodes
		self.starting_addrs = starting_addrs
		self.end_node = end_node
		self.subgraph = subgraph

if __name__ == "__main__":
	if len(sys.argv) < 2:
		print("Usage: firmwall <firmware_path>" )
		sys.exit(1)

	path = sys.argv[1]
	elf_file = path+"/bin/zephyr.elf"
	res_folder = path + "/res"
	func_file = res_folder+"/functions.csv"


	project = angr.Project(elf_file, load_options={'auto_load_libs': False})
	# cfg = project.analyses.CFGFast(show_progressbar=True)
	
	# cfg = project.analyses.CFGEmulated(keep_state=True, show_progressbar=True)
	# plot_cfg(cfg, res_folder + "cfg-latest", format="svg", asminst=True, remove_imports=True, remove_path_terminator=True)

	main = project.loader.main_object.get_symbol("psa_sign_hash")
	print (main)
	start_state = project.factory.blank_state(addr=main.rebased_addr)
	cfg = project.analyses.CFGEmulated(fail_fast=True, starts=[main.rebased_addr], initial_state=start_state, show_progressbar=True)
	plot_cfg(cfg, res_folder + "cfg", format="svg", asminst=True, remove_imports=True, remove_path_terminator=True)

	# function_nodes = []
	# for func_addr, func in cfg.kb.functions.items():
	# 	# print(f"Function name: {func.name}, Address: {hex(func_addr)}")
	# 	# Get the node corresponding to the function address
	# 	func_node = cfg.get_any_node(func_addr)
	# 	if func_node:
	# 		function_nodes.append(func_node)
	
	# print(function_nodes)

	# print("This is the graph:", cfg.graph)
	# print("It has %d nodes and %d edges" % (len(cfg.graph.nodes()), len(cfg.graph.edges())))
	# print(cfg.graph.nodes())

	# print(function_nodes)

	# for x in function_nodes:
	# 	print(x)

	# service_nodes = [

	# 	"psa_crypto_init",
	# 	# Key Management
	# 	"psa_generate_key",
	# 	"psa_import_key",
	# 	"psa_export_key",
	# 	"psa_destroy_key",

	# 	# Hashing
	# 	"psa_hash_setup",
	# 	"psa_hash_update",
	# 	"psa_hash_finish",
	# 	"psa_hash_verify",

	# 	# Message Authentication Codes (MAC)
	# 	"psa_mac_compute",
	# 	"psa_mac_sign_setup",
	# 	"psa_mac_verify_setup",
	# 	"psa_mac_update",
	# 	"psa_mac_sign_finish",
	# 	"psa_mac_verify_finish",

	# 	# Symmetric Encryption and Decryption
	# 	"psa_cipher_encrypt_setup",
	# 	"psa_cipher_decrypt_setup",
	# 	"psa_cipher_update",
	# 	"psa_cipher_finish",

	# 	# Asymmetric Encryption and Decryption
	# 	"psa_asymmetric_encrypt",
	# 	"psa_asymmetric_decrypt",

	# 	# Digital Signatures
	# 	"psa_sign_hash",
	# 	"psa_verify_hash",

	# 	# Key Agreement
	# 	"psa_raw_key_agreement",

	# 	# Random Number Generation
	# 	"psa_generate_random"
	# ]


	# end_nodes = []
	# for node in function_nodes:
	# 	func = cfg.kb.functions.get(node.function_address)
		
	# 	if func and (func.name  in service_nodes):
	# 		# print(func)
	# 		end_nodes.append(node)




	subgraphs = get_subgraphs_to_end_nodes(cfg.graph, end_nodes)

	info = [] 
	# Print the subgraphs or process them as needed
	for end_node, subgraph in subgraphs.items():
		# print(f"Subgraph ending at node {end_node}:")
		# print(subgraph)
		starting_nodes, starting_addrs = get_starting_nodes(subgraph)
		# print(starting_nodes)
		info.append(serviceInfo(starting_nodes, starting_addrs, end_node.name, subgraph))


	# Accessing attributes of the object
	for x in info:
		print("=============================================" )
		print("Starting nodes:", x.starting_nodes)
		# print("Starting addrs:", x.starting_addrs)
		print("End node:", x.end_node)
		print("Subgraph:", x.subgraph)
		print("=============================================" )

		
		
		state = project.factory.entry_state(args=argv)

		'''
		Create a new SimulationManager from the entry state
		'''
		sm = project.factory.simulation_manager(state)

		def check(state):
			if (state.ip.args[0] == addrStrcpy):    # Ensure that we're at strcpy
				'''
				By looking at the disassembly, I've found that the pointer to the
				source buffer given to strcpy() is kept in RSI.  Here, we dereference
				the pointer in RSI and grab 8 bytes (len("HAHAHAHA")) from that buffer.
				'''
				BV_strCpySrc = state.memory.load( state.regs.rsi, len(argv[2]) )
				'''
				Now that we have the contents of the source buffer in the form of a bit
				vector, we grab its string representation using the current state's
				solver engine's function "eval" with cast_to set to str so we get a python string.
				'''
				strCpySrc = state.solver.eval( BV_strCpySrc , cast_to=bytes )
				'''
				Now we simply return True (found path) if we've found a path to strcpy
				where we control the source buffer, or False (keep looking for paths) if we
				don't control the source buffer
				'''
				return True if argv[2].encode() in strCpySrc else False
			else:
				'''
				If we aren't in the strcpy function, we need to tell angr to keep looking
				for new paths.
				'''
				return False

		sm = sm.explore(find=check, avoid=(addrBadFunc,))

		found = sm.found
		'''
		Retrieve a concrete value for the password value from the found path.
		If you put this password in the program's first argument, you should be
		able to strcpy() any string you want into the destination buffer and
		cause a segmentation fault if it is too large :)
		'''
		if len(found) > 0:    #   Make sure we found a path before giving the solution
			found = sm.found[0]
			result = found.solver.eval(argv[1], cast_to=bytes)
			try:
				result = result[:result.index(b'\0')]
			except ValueError:
				pass
		else:   # Aww somehow we didn't find a path.  Time to work on that check() function!
			result = "Couldn't find any paths which satisfied our conditions."
		

	