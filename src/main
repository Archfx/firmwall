#!/usr/bin/env python
import claripy
import angr
from angrutils import *



project = angr.Project('../binaries/tfm_integration/psa_crypto/bin/zephyr.elf', load_options={'auto_load_libs': False})
# project = angr.Project('../binaries/tfm_integration/psa_crypto/bin/tfm_s.elf', load_options={'auto_load_libs': False})
# cfg = p.analyses.CFGFast()
cfg = project.analyses.CFGEmulated(keep_state=True)
print("This is the graph:", cfg.graph)
print("It has %d nodes and %d edges" % (len(cfg.graph.nodes()), len(cfg.graph.edges())))


main = project.loader.main_object.get_symbol("psa_sign_hash")
print (main)
start_state = project.factory.blank_state(addr=main.rebased_addr)
cfg = project.analyses.CFGEmulated(fail_fast=True, starts=[main.rebased_addr], initial_state=start_state)
plot_cfg(cfg, "psa_sign_hash", asminst=True, remove_imports=True, remove_path_terminator=True)
# Generate the control flow graph
# cfg = project.analyses.CFGFast()

# Iterate over all discovered functions
print("List of functions in the binary:")
for func_addr, func in cfg.kb.functions.items():
    print(f"Function name: {func.name}, Address: {hex(func_addr)}")

# cdg = project.analyses.CDG(cfg)
# ddg = project.analyses.DDG(cfg)

# target_func = cfg.kb.functions.function(name="psa_sign_hash")
# print(target_func)

# # We need the CFGNode instance
# target_node = cfg.get_any_node(target_func.addr)

# # Let's get a BackwardSlice out of them!
# # ``targets`` is a list of objects, where each one is either a CodeLocation
# # object, or a tuple of CFGNode instance and a statement ID. Setting statement
# # ID to -1 means the very beginning of that CFGNode. A SimProcedure does not
# # have any statement, so you should always specify -1 for it.
# bs = project.analyses.BackwardSlice(cfg, cdg=cdg, ddg=ddg, targets=[ (target_node, -1) ])

# # Here is our awesome program slice!
# print(bs)

