#!/usr/bin/env python

import sys
import claripy
import angr
from angrutils import *
import networkx as nx
import argparse

import re

import csv
import yaml

import os
from termcolor import colored


sys.path.append('/src/spec_mgr')
from spec_mgr import SpecParse, Argument, Output, read_yaml, create_service_spec


import timeout_decorator

import logging
logging.getLogger('angr.analyses').setLevel('ERROR')
logging.getLogger('angr').setLevel('ERROR')

path = ""
elf_file = ""
func_file = ""

def load_spec(yaml_file):
    with open(yaml_file, 'r') as file:
        return yaml.safe_load(file)

def decode_fn_spec(spec_fn, imp_fn):
    if imp_fn in spec_fn:
        function_details = spec_fn[imp_fn]
        inputs = function_details["inputs"]
        return inputs
    else:
        raise ValueError(f"Function '{function_name}' not found in PSA Crypto functions")


def write_functions_csv( functions, save_csv=True):
	functions = []
	# Iterate over functions and collect data
	for func_addr, func in cfg.kb.functions.items():
		functions.append({
			"func_name": func.name,
			"func_addr": hex(func_addr)
		})
	if (save_csv):
		fields = ["func_name", "func_addr"]
		with open(func_file, mode='w', newline='') as file:
			writer = csv.DictWriter(file, fieldnames=fields)
			writer.writeheader()
			for func in functions:
				writer.writerow(func)
	return functions

def save_cfg(project, start_fn, cfg_name):
	main = project.loader.main_object.get_symbol(start_fn)
	start_state = project.factory.blank_state(addr=main.rebased_addr)
	cfg = project.analyses.CFGEmulated(fail_fast=True, starts=[main.rebased_addr], initial_state=start_state)
	plot_cfg(cfg, cfg_name, format="svg", asminst=True, remove_imports=True, remove_path_terminator=True)

# Function to locate the address of psa_sign_hash
def locate_function(cfg, func_name):
    # cfg = project.analyses.CFGFast()
    for func_addr, func in cfg.kb.functions.items():
        if func.name == func_name:
            return func_addr
    return None

def get_subgraphs_to_end_nodes(cfg_graph, end_nodes, x):
    # Reverse the graph
    reversed_cfg = cfg_graph.reverse()

    subgraphs = {}
    for end_node in end_nodes:
        # Perform DFS up to depth x from the end node in the reversed graph
        def limited_dfs(graph, start_node, depth):
            visited = set()
            stack = [(start_node, 0)]
            while stack:
                node, current_depth = stack.pop()
                if node not in visited and current_depth <= depth:
                    visited.add(node)
                    if current_depth < depth:
                        stack.extend((neighbor, current_depth + 1) for neighbor in graph[node])
            return visited

        reachable_nodes = limited_dfs(reversed_cfg, end_node, x)
        
        # Extract the subgraph from the original CFG
        subgraph = cfg_graph.subgraph(reachable_nodes).copy()
        
        subgraphs[end_node] = subgraph

    return subgraphs

# def get_subgraphs_from_start_nodes(cfg_graph, start_nodes, x):
#     subgraphs = {}
#     for start_node in start_nodes:
#         # Perform DFS up to depth x from the start node in the original graph
#         def limited_dfs(graph, start_node, depth):
#             visited = set()
#             stack = [(start_node, 0)]
#             while stack:
#                 node, current_depth = stack.pop()
#                 if node not in visited and current_depth <= depth:
#                     visited.add(node)
#                     if current_depth < depth:
#                         stack.extend((neighbor, current_depth + 1) for neighbor in graph[node])
#             return visited

#         reachable_nodes = limited_dfs(cfg_graph, start_node, x)
        
#         # Extract the subgraph from the original CFG
#         subgraph = cfg_graph.subgraph(reachable_nodes).copy()
        
#         subgraphs[start_node] = subgraph

#     return subgraphs

def get_subgraphs_from_start_nodes(cfg_graph, start_nodes, x):
    subgraphs = []
    for start_node in start_nodes:
        # Perform DFS up to depth x from the start node in the original graph
        def limited_dfs(graph, start_node, depth):
            visited = set()
            stack = [(start_node, 0)]
            while stack:
                node, current_depth = stack.pop()
                if node not in visited and current_depth <= depth:
                    visited.add(node)
                    if current_depth < depth:
                        stack.extend((neighbor, current_depth + 1) for neighbor in graph[node])
            return visited

        reachable_nodes = limited_dfs(cfg_graph, start_node, x)
        
        # Extract the subgraph from the original CFG
        subgraph = cfg_graph.subgraph(reachable_nodes).copy()
        
        subgraphs.append(subgraph)

    return subgraphs

# Function to extract address from the CFGNode string
def extract_address(node_str):
    # Example: "ecdsa_verify_psa+0x74"
    match = re.search(r'\+(0x[0-9a-fA-F]+)', node_str)
    if match:
        return int(match.group(1), 16)
    else:
        raise ValueError("Invalid node string format")

def get_starting_nodes(subgraph):
	starting_nodes = []
	starting_addrs = []
	for node in subgraph.nodes:
		if subgraph.in_degree(node) == 0:  # No predecessors
			starting_nodes.append(node.name)
			starting_addrs.append(node.addr)
	return starting_nodes, starting_addrs

def get_end_nodes(subgraph):
    end_nodes = []
    end_addrs = []
    for node in subgraph.nodes:
        if subgraph.out_degree(node) == 0:  # No successors
            end_nodes.append(node.name)
            end_addrs.append(node.addr)
    return end_nodes, end_addrs

# Define a path constraint to reach the function
# def is_at_function(state):
# 	return state.addr == function_address

# def is_end_address(state):
#     return state.addr == END_ADDRESS


def get_args():
	# Create the parser
	parser = argparse.ArgumentParser(description="Firmware firmware binary analysis tool.")

	# Add arguments
	parser.add_argument('-d', '--dumpfn', action='store_true', help='Dump available functions in the firmware')
	# parser.add_argument('-n', '--number', type=int, help='A number to process')
	# parser.add_argument('-s', '--string', type=str, help='A string to process')
	# parser.add_argument('-l', '--list', nargs='+', help='A list of values')

	# Parse the arguments
	args = parser.parse_args()

	# Use the arguments
	# if args.verbose:
	#     print("Verbose mode enabled")

	return args.dumpfn

def largest_subgraph_containing_node(graph, node):
    # Find all strongly connected components
    sccs = list(nx.strongly_connected_components(graph))
    
    # Find the SCC containing the particular node
    for scc in sccs:
        if node in scc:
            # Create a subgraph with the nodes in the SCC
            subgraph = graph.subgraph(scc).copy()
            return subgraph
    return None

class serviceInfo:
	def __init__(self, starting_nodes, starting_addrs, end_node, subgraph):
		self.starting_nodes = starting_nodes
		self.starting_addrs = starting_addrs
		self.end_node = end_node
		self.subgraph = subgraph

if __name__ == "__main__":
	if len(sys.argv) < 2:
		print("Usage: firmwall <firmware_path>" )
		sys.exit(1)

	path = sys.argv[1]
	elf_file = path+"/bin/zephyr.elf"
	res_folder = path + "/res"
	func_file = res_folder+"/functions.csv"
	spec_file = path + '/spec/spec.yml'

	print(colored(f"Loading the project at {path}!", "blue", attrs=["reverse", "bold"]))

	if not os.path.exists(elf_file):
		print(colored(f"Could not find the binary file {elf_file}!", "red", attrs=["reverse", "bold"]))

	if not os.path.exists(spec_file):
		print(colored(f"Could not find the specification file {spec_file}!", "red", attrs=["reverse", "bold"]))


	project = angr.Project(elf_file, load_options={'auto_load_libs': False})

	print(colored(f"Parsing the specification at {spec_file}!", "blue", attrs=["reverse", "bold"]))

	spec_data = read_yaml(spec_file)

	assert spec_data, "Unable to read spec data'"

	# Create SpecParse objects
	service_spec = create_service_spec(	spec_data)

	# Print the list of SpecParse objects
	# for function_config in service_spec:
	# 	print(function_config)

	# This CFG is just for decoding function addresses
	# cfg = project.analyses.CFGFast(show_progressbar=True)
	cfg = project.analyses.CFGEmulated(keep_state=True, show_progressbar=True, state_add_options=angr.sim_options.refs, context_sensitivity_level=2)

	

	for function_spec in service_spec:
		function_spec.setAddr(locate_function(cfg, function_spec.name))
		print(function_spec)

	# cfg = project.analyses.CFGEmulated(keep_state=True, show_progressbar=True, state_add_options=angr.sim_options.refs, context_sensitivity_level=2)

	for function_spec in service_spec:
		print(colored(f"Processing the function {function_spec.name}!", "blue", attrs=["reverse", "bold"]))
		func_node = cfg.get_any_node(function_spec.address)
		print(func_node)
		subgraphs = get_subgraphs_from_start_nodes(cfg.graph, [func_node], 100)
		print (subgraphs)
		for x in subgraphs:
			# print("Subgraph has %d nodes and %d edges" % (len(x.nodes()), len(x.edges())))

			end_nodes, end_addrs = get_end_nodes(x)

			print (end_nodes)

		# Create an initial state
		start_state = project.factory.blank_state(addr=function_spec.address)

		# # Create a simulation manager
		simgr = project.factory.simulation_manager(start_state)

		# Define the end address function
		def is_end_address(state):
			if state.addr in end_addrs:
				return True
			else: return False

			# return state.addr == project.loader.main_object.get_symbol(x.end_node)
		
		@timeout_decorator.timeout(1000)  # Timeout in seconds
		def explore_with_timeout(simgr):
			simgr.explore(find=is_end_address)
			return simgr
		
		try:
			# Explore the binary to find the end address with a timeout
			simgr = explore_with_timeout(simgr)

			# Check the results
			if simgr.found:
				found_state = simgr.found[0]
				print("End address reached!")
		except timeout_decorator.timeout_decorator.TimeoutError:
			print("Symbolic execution timed out.")

		# # Explore the binary to find the end address
		# simgr.explore(find=is_end_address)

		# Check the results
		if simgr.found:
			found_state = simgr.found[0]
			print("End address reached!")

# ================

	# end_nodes = []
	# for node in function_nodes:
	# 	func = cfg.kb.functions.get(node.function_address)
		
	# 	if func and (func.name  in service_nodes):
	# 		# print(func)
	# 		end_nodes.append(node)

	# # subgraphs = get_subgraphs_to_end_nodes(cfg.graph, end_nodes, 1)
	# subgraphs =  get_subgraphs_from_start_nodes(cfg.graph, end_nodes, 10)
	# info = [] 
	# # Print the subgraphs or process them as needed
	# for end_node, subgraph in subgraphs.items():
	# 	# print(f"Subgraph ending at node {end_node}:")
	# 	# print(subgraph)
	# 	starting_nodes, starting_addrs = get_starting_nodes(subgraph)
	# 	end_nodes = get_end_nodes(subgraph)
	# 	# print(starting_nodes)
	# 	info.append(serviceInfo(starting_nodes, starting_addrs, end_nodes, subgraph))
	# # dumpfn = get_args()

	# # Accessing attributes of the object
	# for x in info:
	# 	print("=============================================" )
	# 	print("Starting nodes:", x.starting_nodes)
	# 	# print("Starting addrs:", x.starting_addrs)
	# 	print("End node:", x.end_node)
	# 	print("Subgraph:", x.subgraph)
	# 	print("=============================================" )


		
	# 	# end_node = project.loader.main_object.get_symbol(x.end_node)
	# 	# start_node_addr = []
	# 	# for y in x.starting_nodes:
	# 	# 	start_node_addr.append(project.loader.main_object.get_symbol(y))
			
	# 	# print (start_node)
	# 	# start_state = project.factory.blank_state(addr=start_node.rebased_addr)
		
	# 	avoid_addrs=[1069979, 1063833, 1070069, 1050167]
	# 	subcfg = project.analyses.CFGEmulated( starts=x.starting_addrs , resolve_indirect_jumps=True, base_graph = x.subgraph, avoid_runs=avoid_addrs, show_progressbar=True)
	# 	print("building CDG")
	# 	# Generate the control dependence graph
	# 	cdg = project.analyses.CDG(cfg, show_progressbar=True)

	# 	print("building DDG")
	# 	# Build the data dependence graph. It might take a while. Be patient!
	# 	ddg = project.analyses.DDG(cfg, show_progressbar=True)

	# 	target_func = cfg.kb.functions.function(name=x.starting_nodes[0])
	# 	target_node = cfg.get_any_node(target_func.addr)
	# 	bs = project.analyses.BackwardSlice(cfg, cdg=cdg, ddg=ddg, targets=[ (target_node, -1) ])

	# 	print(bs)

	# 	# # # subcfg = project.analyses.CFGEmulated( starts=x.starting_addrs, show_progressbar=True)
	# 	# for y in range (len(x.starting_addrs)):
	# 	# 	if (x.starting_addrs[y] not in avoid_addrs):
	# 	# 		print("using addr", x.starting_addrs[y], x.starting_nodes[y])
	# 	# 		# subcfg = project.analyses.CFGEmulated( starts=[x.starting_addrs[y]] , resolve_indirect_jumps=True, show_progressbar=True)


	# 	# 		# # main = project.loader.main_object.get_symbol(x.starting_addrs[y])
	# 	# 		# # print (main)
	# 	# 		# start_state = project.factory.blank_state(addr=x.starting_addrs[y])
	# 	# 		# subcfg = project.analyses.CFGEmulated(fail_fast=True, starts=[x.starting_addrs[y]], initial_state=start_state, show_progressbar=True)
	# 	# 		# plot_cfg(subcfg, res_folder + starting_nodes[y] + "_cfg", format="svg", asminst=True, remove_imports=True, remove_path_terminator=True)
	# 	# 		# plot_cfg(subcfg, res_folder + "/cfg_"+x.end_node, format="svg", asminst=True, remove_imports=True, remove_path_terminator=True)

	# 	# 		# Create an initial state
	# 	# 		start_state = project.factory.blank_state(addr=x.starting_addrs[y])

	# 	# 		# Create a simulation manager
	# 	# 		simgr = project.factory.simulation_manager(start_state)

	# 	# 		# Define the end address function
	# 	# 		def is_end_address(state):
	# 	# 			return state.addr == project.loader.main_object.get_symbol(x.end_node)
				
	# 	# 		@timeout_decorator.timeout(1000)  # Timeout in seconds
	# 	# 		def explore_with_timeout(simgr):
	# 	# 			simgr.explore(find=is_end_address)
	# 	# 			return simgr
				
	# 	# 		try:
	# 	# 			# Explore the binary to find the end address with a timeout
	# 	# 			simgr = explore_with_timeout(simgr)

	# 	# 			# Check the results
	# 	# 			if simgr.found:
	# 	# 				found_state = simgr.found[0]
	# 	# 				print("End address reached!")
	# 	# 		except timeout_decorator.timeout_decorator.TimeoutError:
	# 	# 			print("Symbolic execution timed out.")

	# 	# 		# # Explore the binary to find the end address
	# 	# 		# simgr.explore(find=is_end_address)

	# 			# # Check the results
	# 			# if simgr.found:
	# 			# 	found_state = simgr.found[0]
	# 			# 	print("End address reached!")
	# 	# Locate the psa_sign_hash function

	# # 	# ===================
	# # 	# Function of interest
	# # 	function_name = x.end_node
	# # 	function = cfg.kb.functions.function(name=function_name)
	# # 	function_address = function.addr
	# # 	print(f"Function {function_name} is at address: {hex(function_address)}")

	# # 	# Create a blank state at the entry point
	# # 	initial_state = project.factory.blank_state(addr=project.entry)

	# # 	# Setup the path group for exploration
	# # 	simgr = project.factory.simulation_manager(initial_state)
	# # 	simgr.step()
	# # 	print(simgr.active)

		
	# # 	print("test point 1")
	# # 	# Explore all paths to the function
	# # 	# simgr.explore(find=is_at_function, show_progressbar=True)
	# # 	simgr.explore(find=lambda s: s.addr == function_address + 4)
		
	# # 	print("test point 2")
	# # 	# Iterate through found paths
	# # 	for found in simgr.found:
	# # 		# Get the call site of the function
	# # 		caller_state = found.history.bbl_addrs[-2]  # Assuming the function is directly called
			
	# # 		# Analyze the data flow to the function's inputs
	# # 		for arg in found.callstack.current_args:
	# # 			print(f"Argument value: {arg}")

	# # 			# Perform further analysis if needed, such as tracking the source of the data
	# # 			# Example: Get the symbolic expression of the argument
	# # 			symbolic_expr = found.solver.eval(arg)
	# # 			print(f"Symbolic expression: {symbolic_expr}")

	# # 	# if (x.end_node == 'psa_sign_hash'):
	# # 	# 	func_addr = locate_function(project, 'psa_sign_hash')
	# # 	# 	if func_addr is None:
	# # 	# 		raise Exception("Function psa_sign_hash not found in the binary")

	# # 	# 	# # Create a state at the start of the psa_sign_hash function
	# # 	# 	state = project.factory.blank_state(addr=func_addr)

	# # 	# 	# Define function arguments
	# # 	# 	key = claripy.BVS('key', 32)  # Assume 32-bit key ID
	# # 	# 	alg = claripy.BVS('alg', 32)  # Assume 32-bit algorithm ID
	# # 	# 	hash_ptr = claripy.BVV(0x10000000, 32)  # Assume a hash pointer at 0x10000000
	# # 	# 	hash_length = claripy.BVS('hash_length', 32)  # Size of the hash buffer
	# # 	# 	signature_ptr = claripy.BVV(0x20000000, 32)  # Assume a signature buffer pointer at 0x20000000
	# # 	# 	signature_size = claripy.BVS('signature_size', 32)  # Size of the signature buffer
	# # 	# 	signature_length_ptr = claripy.BVV(0x30000000, 32)  # Assume a pointer to the signature length

	# # 	# 	# Set registers or stack values for the function arguments
	# # 	# 	state.regs.r0 = key
	# # 	# 	state.regs.r1 = alg
	# # 	# 	state.regs.r2 = hash_ptr
	# # 	# 	state.regs.r3 = hash_length
	# # 	# 	state.regs.r4 = signature_ptr
	# # 	# 	state.regs.r5 = signature_size
	# # 	# 	state.regs.r6 = signature_length_ptr

	# # 	# 	# Define constraints for valid parameters
	# # 	# 	state.solver.add(key != 0)
	# # 	# 	state.solver.add(alg != 0)
	# # 	# 	state.solver.add(hash_ptr != 0)
	# # 	# 	state.solver.add(hash_length > 0)
	# # 	# 	state.solver.add(signature_ptr != 0)
	# # 	# 	state.solver.add(signature_size > 0)
	# # 	# 	state.solver.add(signature_length_ptr != 0)

	# # 	# 	# Simulate the function
	# # 	# 	simgr = project.factory.simulation_manager(state)
	# # 	# 	simgr.explore(find=lambda s: s.addr == func_addr + 4)  # Adjust the offset as needed

	# # 	# 	# Check results
	# # 	# 	if simgr.found:
	# # 	# 		for found_state in simgr.found:
	# # 	# 			print("Assertions satisfied at address:", hex(found_state.addr))
	# # 	# 	else:
	# # 	# 		print("No paths found that satisfy the assertions.")		

	# # # if dumpfn:
	# # write_functions_csv(cfg.kb.functions.items());	
	