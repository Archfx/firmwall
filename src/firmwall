#!/usr/bin/env python

import sys
import claripy
import angr
from angrutils import *
import networkx as nx
import argparse

import re

import csv
import yaml

path = ""
elf_file = ""
func_file = ""

def load_spec(yaml_file):
    with open(yaml_file, 'r') as file:
        return yaml.safe_load(file)

def decode_fn_spec(spec_fn, imp_fn):
    if imp_fn in spec_fn:
        function_details = spec_fn[imp_fn]
        inputs = function_details["inputs"]
        return inputs
    else:
        raise ValueError(f"Function '{function_name}' not found in PSA Crypto functions")


def write_functions_csv( functions, save_csv=True):
	functions = []
	# Iterate over functions and collect data
	for func_addr, func in cfg.kb.functions.items():
		functions.append({
			"func_name": func.name,
			"func_addr": hex(func_addr)
		})
	if (save_csv):
		fields = ["func_name", "func_addr"]
		with open(func_file, mode='w', newline='') as file:
			writer = csv.DictWriter(file, fieldnames=fields)
			writer.writeheader()
			for func in functions:
				writer.writerow(func)
	return functions

def save_cfg(project, start_fn, cfg_name):
	main = project.loader.main_object.get_symbol(start_fn)
	start_state = project.factory.blank_state(addr=main.rebased_addr)
	cfg = project.analyses.CFGEmulated(fail_fast=True, starts=[main.rebased_addr], initial_state=start_state)
	plot_cfg(cfg, cfg_name, format="svg", asminst=True, remove_imports=True, remove_path_terminator=True)


def get_subgraphs_to_end_nodes(cfg_graph, end_nodes):
    # Reverse the graph
    reversed_cfg = cfg_graph.reverse()

    subgraphs = {}
    for end_node in end_nodes:
        # Use DFS to find all reachable nodes from the end node in the reversed graph
        reachable_nodes = set(nx.dfs_preorder_nodes(reversed_cfg, source=end_node))
        
        # Extract the subgraph from the original CFG
        subgraph = cfg_graph.subgraph(reachable_nodes).copy()
        
        subgraphs[end_node] = subgraph

    return subgraphs

# Function to extract address from the CFGNode string
def extract_address(node_str):
    # Example: "ecdsa_verify_psa+0x74"
    match = re.search(r'\+(0x[0-9a-fA-F]+)', node_str)
    if match:
        return int(match.group(1), 16)
    else:
        raise ValueError("Invalid node string format")

def get_starting_nodes(subgraph):
	starting_nodes = []
	starting_addrs = []
	for node in subgraph.nodes:
		if subgraph.in_degree(node) == 0:  # No predecessors
			starting_nodes.append(node.name)
			starting_addrs.append(node.addr)
	return starting_nodes, starting_addrs


def get_args():
	# Create the parser
	parser = argparse.ArgumentParser(description="Firmware firmware binary analysis tool.")

	# Add arguments
	parser.add_argument('-d', '--dumpfn', action='store_true', help='Dump available functions in the firmware')
	# parser.add_argument('-n', '--number', type=int, help='A number to process')
	# parser.add_argument('-s', '--string', type=str, help='A string to process')
	# parser.add_argument('-l', '--list', nargs='+', help='A list of values')

	# Parse the arguments
	args = parser.parse_args()

	# Use the arguments
	# if args.verbose:
	#     print("Verbose mode enabled")

	return args.dumpfn

class serviceInfo:
	def __init__(self, starting_nodes, starting_addrs, end_node, subgraph):
		self.starting_nodes = starting_nodes
		self.starting_addrs = starting_addrs
		self.end_node = end_node
		self.subgraph = subgraph

if __name__ == "__main__":
	if len(sys.argv) < 2:
		print("Usage: firmwall <firmware_path>" )
		sys.exit(1)

	path = sys.argv[1]
	elf_file = path+"/bin/zephyr.elf"
	func_file = path+"/res/functions.csv"

	project = angr.Project(elf_file, load_options={'auto_load_libs': False})
	cfg = project.analyses.CFGFast()
	# cfg = project.analyses.CFGEmulated(keep_state=True)

	function_nodes = []
	for func_addr, func in cfg.kb.functions.items():
		# print(f"Function name: {func.name}, Address: {hex(func_addr)}")
		# Get the node corresponding to the function address
		func_node = cfg.get_any_node(func_addr)
		if func_node:
			function_nodes.append(func_node)
	
	# print(function_nodes)

	# print("This is the graph:", cfg.graph)
	# print("It has %d nodes and %d edges" % (len(cfg.graph.nodes()), len(cfg.graph.edges())))
	# print(cfg.graph.nodes())

	# print(function_nodes)

	# for x in function_nodes:
	# 	print(x)

	service_nodes = [

		"psa_crypto_init",
		# Key Management
		"psa_generate_key",
		"psa_import_key",
		"psa_export_key",
		"psa_destroy_key",

		# Hashing
		"psa_hash_setup",
		"psa_hash_update",
		"psa_hash_finish",
		"psa_hash_verify",

		# Message Authentication Codes (MAC)
		"psa_mac_compute",
		"psa_mac_sign_setup",
		"psa_mac_verify_setup",
		"psa_mac_update",
		"psa_mac_sign_finish",
		"psa_mac_verify_finish",

		# Symmetric Encryption and Decryption
		"psa_cipher_encrypt_setup",
		"psa_cipher_decrypt_setup",
		"psa_cipher_update",
		"psa_cipher_finish",

		# Asymmetric Encryption and Decryption
		"psa_asymmetric_encrypt",
		"psa_asymmetric_decrypt",

		# Digital Signatures
		"psa_sign_hash",
		"psa_verify_hash",

		# Key Agreement
		"psa_raw_key_agreement",

		# Random Number Generation
		"psa_generate_random"
	]


	end_nodes = []
	for node in function_nodes:
		func = cfg.kb.functions.get(node.function_address)
		
		if func and (func.name  in service_nodes):
			# print(func)
			end_nodes.append(node)




	subgraphs = get_subgraphs_to_end_nodes(cfg.graph, end_nodes)

	info = [] 
	# Print the subgraphs or process them as needed
	for end_node, subgraph in subgraphs.items():
		# print(f"Subgraph ending at node {end_node}:")
		# print(subgraph)
		starting_nodes, starting_addrs = get_starting_nodes(subgraph)
		# print(starting_nodes)
		info.append(serviceInfo(starting_nodes, starting_addrs, end_node.name, subgraph))
	# dumpfn = get_args()

	# Accessing attributes of the object
	for x in info:
		print("=============================================" )
		print("Starting nodes:", x.starting_nodes)
		print("Starting addrs:", x.starting_addrs)
		print("End node:", x.end_node)
		print("Subgraph:", x.subgraph)
		print("=============================================" )
		
		end_node = project.loader.main_object.get_symbol(x.end_node)
		# start_node_addr = []
		# for y in x.starting_nodes:
		# 	start_node_addr.append(project.loader.main_object.get_symbol(y))
			
		# print (start_node)
		# start_state = project.factory.blank_state(addr=start_node.rebased_addr)
		avoid_addrs=[1069979, 1063833]

		cfg = project.analyses.CFGEmulated( starts=x.starting_addrs , resolve_indirect_jumps=True, base_graph = x.subgraph, avoid_runs=avoid_addrs)
		# for y in range (len(x.starting_addrs)):
		# 	if (x.starting_addrs[y] not in avoid_addrs):
		# 		print("using addr", x.starting_addrs[y], x.starting_nodes[y])
		# 		cfg = project.analyses.CFGEmulated( starts=[x.starting_addrs[y]] , resolve_indirect_jumps=True, )
				

	# if dumpfn:
	write_functions_csv(cfg.kb.functions.items());	
	